/**
 * ID Generation Tests
 * 
 * ═══════════════════════════════════════════════════════════════════════════════
 * NOTE: Trade IDs are now generated by the DATABASE, not client-side.
 * 
 * These tests validate the deprecated client-side functions still work
 * for backward compatibility, but NEW CODE should use DB-generated IDs.
 * 
 * DB-FIRST FLOW:
 * 1. Insert trade WITHOUT id field
 * 2. Supabase uses gen_random_uuid() as default
 * 3. Capture returned ID via .select('id').single()
 * 4. Attach ID to in-memory objects
 * ═══════════════════════════════════════════════════════════════════════════════
 */

import { generateUUID } from '../src/utils/id';
import { generateUUID as generateHardenedUUID } from '../src/utils/tradeId';

describe('ID Generation (Non-Trade Use Cases)', () => {
    describe('generateUUID', () => {
        test('always returns unique values', () => {
            const a = generateUUID();
            const b = generateUUID();
            expect(a).not.toBe(b);
        });

        test('generates collision-resistant format with UUID and nanoseconds', () => {
            const id = generateUUID();
            // Format: uuid-nanoseconds (uuid is 36 chars, dash, then nanoseconds)
            // UUID v4: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx (36 chars)
            // Full format: uuid-nanoseconds
            const collisionResistantRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}-\d+$/i;
            expect(id).toMatch(collisionResistantRegex);
        });

        test('generates unique values across many calls', () => {
            const ids = new Set<string>();
            const count = 1000;
            
            for (let i = 0; i < count; i++) {
                ids.add(generateUUID());
            }
            
            expect(ids.size).toBe(count);
        });

        test('includes retry suffix when attempt > 0', () => {
            const retryId = generateUUID(1);
            // Format: uuid-nanoseconds-r1
            expect(retryId).toMatch(/-r1$/);
        });

        test('different retry attempts produce different suffixes', () => {
            const retry1 = generateUUID(1);
            const retry2 = generateUUID(2);
            expect(retry1).toMatch(/-r1$/);
            expect(retry2).toMatch(/-r2$/);
        });
    });

    describe('Hardened UUID Generator (tradeId.ts)', () => {
        test('generates IDs with nanosecond entropy', () => {
            const id1 = generateHardenedUUID();
            const id2 = generateHardenedUUID();
            
            // Extract nanosecond parts
            const nano1 = id1.split('-').pop();
            const nano2 = id2.split('-').pop();
            
            // Nanoseconds should be different (unless machine is impossibly fast)
            expect(nano1).not.toBe(nano2);
        });

        test('retry IDs have correct suffix format', () => {
            const id0 = generateHardenedUUID(0);
            const id1 = generateHardenedUUID(1);
            const id3 = generateHardenedUUID(3);
            
            expect(id0).not.toMatch(/-r\d+$/);
            expect(id1).toMatch(/-r1$/);
            expect(id3).toMatch(/-r3$/);
        });
    });

    describe('No ID Reuse Verification', () => {
        test('rapid generation produces unique IDs', () => {
            const ids: string[] = [];
            
            // Generate many IDs rapidly
            for (let i = 0; i < 100; i++) {
                ids.push(generateUUID());
            }
            
            // All should be unique
            const uniqueIds = new Set(ids);
            expect(uniqueIds.size).toBe(ids.length);
        });

        test('concurrent generation produces unique IDs', async () => {
            const promises = Array.from({ length: 100 }, () => 
                Promise.resolve(generateUUID())
            );
            
            const ids = await Promise.all(promises);
            const uniqueIds = new Set(ids);
            
            expect(uniqueIds.size).toBe(ids.length);
        });

        test('nanosecond entropy prevents same-millisecond collisions', () => {
            // Generate IDs as fast as possible to test nanosecond differentiation
            const ids: string[] = [];
            for (let i = 0; i < 10000; i++) {
                ids.push(generateHardenedUUID());
            }
            
            const uniqueIds = new Set(ids);
            expect(uniqueIds.size).toBe(ids.length);
        });
    });
});

describe('DB-First Trade ID Flow (Integration Notes)', () => {
    /**
     * These are documentation tests - they don't actually test DB functionality
     * but document the expected flow for trade ID generation.
     */
    
    test('trade IDs should come from database, not client', () => {
        // This is a documentation test
        // In production, the flow is:
        // 1. const { data } = await supabase.from('trades').insert({...}).select('id').single()
        // 2. const tradeId = data.id
        // 3. trade.id = tradeId
        expect(true).toBe(true);
    });

    test('position IDs should use the trade ID from database', () => {
        // Position ID = Trade ID (assigned by database)
        // In production: position.tradeId = dbGeneratedTradeId
        expect(true).toBe(true);
    });

    test('capital allocation uses DB-assigned trade ID', () => {
        // In production:
        // 1. Insert trade → get dbGeneratedId
        // 2. capitalManager.allocate(dbGeneratedId, amount)
        expect(true).toBe(true);
    });
});
