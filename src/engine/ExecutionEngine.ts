/**
 * ExecutionEngine.ts - Stateful Execution Engine
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * TIER 4 EXECUTION ENGINE â€” STATEFUL MODE WITH INTERNAL LOOPS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ARCHITECTURAL RULES:
 * 1. Engine runs internal timers for continuous monitoring
 * 2. ScanLoop still runs every 120s but is NOT the sole driver
 * 3. Engine evaluates exit conditions continuously
 * 4. Positions are monitored in real-time
 * 
 * PUBLIC API:
 * - initialize() â€” one-time setup, recovers positions from DB
 * - start() â€” starts all internal runtime loops
 * - stop() â€” stops all internal loops gracefully
 * - placePools(pools) â€” evaluate and queue pools for entry
 * - executeEntry(pool, size) â€” execute a single entry
 * - executeExit(positionId, reason) â€” execute a single exit
 * - evaluatePositionHealth(positionId) â€” check if position should exit
 * - getPortfolioStatus() â€” get current state
 * - closeAll(reason) â€” emergency close all
 * 
 * INTERNAL LOOPS (started by start()):
 * - Price watcher (5s) â€” updates position prices
 * - Exit watcher (10s) â€” evaluates exit conditions
 * - Snapshot timer (60s) â€” writes portfolio snapshots
 * - PnL drift updater (15s) â€” recalculates unrealized PnL
 * - Regime updater (30s) â€” updates regime and migration direction
 * - Bin tracker (5s) â€” tracks bin movements
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import logger from '../utils/logger';
import {
    computeMicrostructureMetrics,
    MicrostructureMetrics,
    registerPosition,
    unregisterPosition,
    BinFocusedPosition,
    getSwapHistory,
    getPoolHistory,
} from '../services/dlmmTelemetry';
import {
    getMomentumSlopes,
    computeSlopeMultiplier,
    recordEntryBaseline,
    clearEntryBaseline,
    clearNegativeVelocityCount,
    getEntryBaseline,
} from '../scoring/momentumEngine';
import {
    computeTier4Score,
    evaluateTier4Entry,
    logTier4Cycle,
    logEntryBlock,
    getBinWidthConfig,
    checkMigrationBlock,
    Tier4EnrichedPool,
    REGIME_THRESHOLDS,
} from '../scoring/microstructureScoring';
import {
    calcEntrySize,
    calcScaleSize,
    canAddPosition,
    calcBinWidth,
} from './positionSizingEngine';
import {
    MarketRegime,
    MigrationDirection,
    BinWidthConfig,
    Tier4Score,
} from '../types';
import { capitalManager } from '../services/capitalManager';
import { 
    saveTradeToDB, 
    createTradeInput,
    updateTradeExitInDB,
    registerTrade,
    unregisterTrade,
    getAllActiveTrades,
    createDefaultExecutionData,
    Trade,
    TradeInput,
    TradeExitState,
    canExitTrade,
    acquireExitLock,
    markTradeClosed,
    releaseExitLock,
    getTrade,
} from '../db/models/Trade';
import { RiskTier, assignRiskTier, calculateLeverage } from './riskBucketEngine';
import { logAction } from '../db/supabase';
import {
    persistTradeEntry,
    persistTradeExit,
    updatePositionState,
    loadPositionsBySealedIds,
    PositionLike,
} from '../integrations/persistence/tradePersistence';
import {
    evaluateHarmonicStop,
    registerHarmonicTrade,
    unregisterHarmonicTrade,
    createMicroMetricsSnapshot,
    createHarmonicContext,
    MicroMetricsSnapshot,
    HarmonicDecision,
} from './harmonicStops';
import {
    logTradeEntry,
    logTradeExit,
    reconcilePnL,
    correctPnLDrift,
    computeRealizedPnLFromDb,
} from '../services/pnlService';
import {
    getActiveRunId,
    getStartingCapitalThisRun,
    sanityCheckEquity,
} from '../services/runEpoch';
import {
    getDbPositionCounts,
    hasReconciliationCompleted,
} from '../services/positionReconciler';
import {
    assertEngineModeUnchanged,
    isReconciliationSealed,
    getSealedOpenPositionIds,
    getSealedOpenPositionCount,
    assertReconciliationSealed,
} from '../state/reconciliationSeal';
import {
    computePositionMtmUsd,
    computeExitMtmUsd,
    createDefaultPriceFeed,
    createPositionForMtm,
    logPnlUsdWithMtm,
    logTradeExitWithMtm,
    MTMValuation,
    PoolStateForMTM,
    PriceFeed,
    incrementExitWatcherCycle,
    clearPositionMtmCache,
    shouldForceExitDueToMtmError,
    resetConsecutiveUnchangedCount,
} from '../capital/mtmValuation';
import {
    shouldSuppressNoiseExit,
    isRiskExit,
    isNoiseExit,
    recordSuppressionCheck,
    EXIT_CONFIG,
    SuppressionResult,
} from '../capital/exitHysteresis';
// Note: Trade IDs are now generated by the database, not client-side

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERFACES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface TokenInfo {
    symbol: string;
    decimals: number;
}

export interface ScoredPool {
    address: string;
    score: number;
    liquidityUSD: number;
    volume24h: number;
    binCount: number;
    activeBin: number;
    tokenA: TokenInfo;
    tokenB: TokenInfo;
    
    // Tier 4 enrichment
    tier4?: Tier4Score | null;
    microMetrics?: MicrostructureMetrics;
    isMarketAlive?: boolean;
    
    // Tier 4 quick access
    tier4Score?: number;
    regime?: MarketRegime;
    migrationDirection?: MigrationDirection;
    entryThreshold?: number;
    exitThreshold?: number;
    binWidth?: BinWidthConfig;
    
    // Slopes
    velocitySlope?: number;
    liquiditySlope?: number;
    entropySlope?: number;
}

export interface Position {
    id: string;               // Trade ID from database
    pool: string;
    symbol: string;
    entryPrice: number;
    currentPrice: number;
    sizeUSD: number;
    pnl: number;
    pnlPercent: number;
    bins: number[];
    openedAt: number;
    closedAt?: number;
    closed: boolean;
    exitReason?: string;
    
    // Bin-focused tracking
    entryBin: number;
    currentBin: number;
    binOffset: number;
    
    // Microstructure at entry
    entryFeeIntensity: number;
    entrySwapVelocity: number;
    entry3mFeeIntensity: number;
    
    // Tier 4: Entry state
    entryTier4Score: number;
    entryRegime: MarketRegime;
    entryMigrationDirection: MigrationDirection;
    entryVelocitySlope: number;
    entryLiquiditySlope: number;
    entryEntropySlope: number;
    entryBinWidth: BinWidthConfig;
    entryThreshold: number;
    exitThreshold: number;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXIT STATE GUARD - SINGLE EXIT AUTHORITY PATTERN
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    exitState: 'open' | 'closing' | 'closed';
    pendingExit: boolean;
}

export interface PortfolioSnapshot {
    capital: number;
    lockedCapital: number;
    totalEquity: number;
    openPositions: Position[];
    closedPositions: Position[];
    realized: number;
    unrealized: number;
    equity: number;
    ts: Date;
}

export interface ExecutionEngineConfig {
    capital?: number;
    takeProfit?: number;
    stopLoss?: number;
    maxConcurrentPools?: number;
    allocationStrategy?: 'equal' | 'weighted';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIER 4 EXIT EVALUATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface Tier4ExitEvaluation {
    shouldExit: boolean;
    reason: string;
    tier4Score: number;
    exitThreshold: number;
    regime: MarketRegime;
    feeIntensityDrop: number;
    migrationReversal: boolean;
}

export interface PositionHealthEvaluation {
    positionId: string;
    shouldExit: boolean;
    exitReason: string;
    exitType: 'HARMONIC' | 'TIER4' | 'NONE';
    tier4Eval?: Tier4ExitEvaluation;
    harmonicDecision?: HarmonicDecision;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DEFAULT_CAPITAL = 10_000;
const DEFAULT_TAKE_PROFIT = 0.04;
const DEFAULT_STOP_LOSS = -0.02;
const DEFAULT_MAX_CONCURRENT_POOLS = 3;
const TICK_SPACING_ESTIMATE = 0.0001;

// Tier 4 exit thresholds
const EXIT_THRESHOLDS = {
    feeIntensityCollapse: 0.35,
};

const MAX_EXPOSURE = 0.30;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DB-FIRST TRADE PERSISTENCE (UUID generated by database)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Release capital lock for a trade entry that failed to persist.
 * CRITICAL: Must be called on any persistence failure to prevent orphan locks.
 * 
 * @param tradeId - The trade ID whose capital lock should be released
 */
async function releaseCapitalLock(tradeId: string): Promise<void> {
    try {
        await capitalManager.release(tradeId);
        logger.info(`[CAPITAL] Released lock for failed trade ${tradeId.slice(0, 8)}...`);
    } catch (releaseErr: any) {
        logger.error(`[CAPITAL] Failed to release lock for trade ${tradeId.slice(0, 8)}...: ${releaseErr.message}`);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATEFUL MODE INTERVALS (milliseconds)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PRICE_WATCHER_INTERVAL = 4_000;      // 4 seconds (tuned from 5s)
const EXIT_WATCHER_INTERVAL = 8_000;       // 8 seconds (tuned from 10s)
const SNAPSHOT_INTERVAL = 45_000;          // 45 seconds (tuned from 60s)
const PNL_DRIFT_INTERVAL = 15_000;         // 15 seconds
const REGIME_UPDATER_INTERVAL = 30_000;    // 30 seconds
const BIN_TRACKER_INTERVAL = 5_000;        // 5 seconds
const PNL_AUDITOR_INTERVAL = 5 * 60_000;   // 5 minutes - PnL reconciliation

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXECUTION ENGINE CLASS â€” STATEFUL EXECUTOR WITH INTERNAL LOOPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class ExecutionEngine {
    private initialCapital: number;
    private takeProfit: number;
    private stopLoss: number;
    private maxConcurrentPools: number;
    private allocationStrategy: 'equal' | 'weighted';

    public positions: Position[] = [];
    private closedPositions: Position[] = [];
    private poolQueue: ScoredPool[] = [];
    private initialized: boolean = false;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATEFUL MODE â€” INTERNAL LOOP TIMERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private running: boolean = false;
    private priceWatcherTimer: NodeJS.Timeout | null = null;
    private exitWatcherTimer: NodeJS.Timeout | null = null;
    private snapshotTimer: NodeJS.Timeout | null = null;
    private pnlDriftTimer: NodeJS.Timeout | null = null;
    private regimeUpdaterTimer: NodeJS.Timeout | null = null;
    private binTrackerTimer: NodeJS.Timeout | null = null;
    private pnlAuditorTimer: NodeJS.Timeout | null = null;
    
    // Loop execution guards (prevent overlapping runs)
    private priceWatcherRunning: boolean = false;
    private exitWatcherRunning: boolean = false;
    private snapshotRunning: boolean = false;
    private pnlDriftRunning: boolean = false;
    private regimeUpdaterRunning: boolean = false;
    private binTrackerRunning: boolean = false;
    private pnlAuditorRunning: boolean = false;
    
    // PnL tracking - cached values for quick access
    private cachedRealizedPnL: number = 0;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BIN ACCELERATION TRACKING (Second-Order Delta)
    // Used as exit context only, NOT a new exit trigger
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private binVelocityHistory: Map<string, { ts: number; velocity: number }[]> = new Map();
    private binAcceleration: Map<string, number> = new Map(); // positionId â†’ acceleration (bins/secÂ²)
    private static readonly BIN_VELOCITY_HISTORY_SIZE = 5; // Keep last 5 velocity samples

    /**
     * Returns true if engine is in STATEFUL mode (internal loops running)
     * ScanLoop MUST verify this is true before operating
     * 
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * RULE 3: ENGINE MODE IS LOCKED POST-RECONCILIATION
     * After reconciliation seal, engine mode MUST remain STATEFUL
     * Any downgrade attempt â†’ fatal error
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */
    public get isStateful(): boolean {
        const mode = this.running ? 'STATEFUL' : 'STATELESS';
        
        // If reconciliation is sealed, assert mode hasn't changed
        if (isReconciliationSealed()) {
            assertEngineModeUnchanged(mode);
        }
        
        return this.running;
    }

    constructor(config: ExecutionEngineConfig = {}) {
        this.initialCapital = config.capital ?? DEFAULT_CAPITAL;
        this.takeProfit = config.takeProfit ?? DEFAULT_TAKE_PROFIT;
        this.stopLoss = config.stopLoss ?? DEFAULT_STOP_LOSS;
        this.maxConcurrentPools = config.maxConcurrentPools ?? DEFAULT_MAX_CONCURRENT_POOLS;
        this.allocationStrategy = config.allocationStrategy ?? 'equal';

        logger.info('[ENGINE] Stateful mode enabled');
        logger.info('[EXECUTION] Engine instance created (STATEFUL MODE)', {
            initialCapital: this.initialCapital,
            maxExposure: `${MAX_EXPOSURE * 100}%`,
            maxConcurrentPools: this.maxConcurrentPools,
        });
    }

    /**
     * Initialize engine - recovers positions from database using sealed position IDs
     * 
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * CRITICAL: Position hydration MUST use sealed position IDs ONLY.
     * ExecutionEngine MUST NOT query the trades table to determine open positions.
     * The positions table is the SINGLE SOURCE OF TRUTH for open positions.
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * 
     * NOTE: Capital manager is already initialized by bootstrap.ts
     * DO NOT call capitalManager.initialize() here - it's already done.
     */
    async initialize(): Promise<boolean> {
        if (this.initialized) {
            return true;
        }

        try {
            // Verify capital manager is ready
            const balance = await capitalManager.getBalance();
            if (balance < 0) {
                logger.error('[EXECUTION] âŒ Capital manager not ready');
                return false;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CRITICAL: Assert reconciliation seal is set BEFORE loading positions
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            assertReconciliationSealed('ExecutionEngine.initialize');
            
            // Get sealed position IDs - the AUTHORITATIVE source for position hydration
            const sealedPositionIds = getSealedOpenPositionIds();
            const sealedCount = getSealedOpenPositionCount();
            
            logger.info(`[EXECUTION] Hydrating ${sealedCount} positions from reconciliation seal...`);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Load positions ONLY by sealed IDs (positions table is source of truth)
            // This function will process.exit(1) if count doesn't match sealed count
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const sealedPositions = await loadPositionsBySealedIds(sealedPositionIds);
            
            // Convert PositionLike to Position and register for harmonic monitoring
            for (const posLike of sealedPositions) {
                const position = this.positionLikeToPosition(posLike);
                if (position) {
                    this.positions.push(position);
                    
                    // Register recovered trade for harmonic monitoring
                    const baselineSnapshot = createMicroMetricsSnapshot(
                        posLike.entryTime,
                        0.05, // Default velocity ratio
                        0.1,  // Default velocity
                        0,
                        0.7,
                        0.02,
                        posLike.velocitySlope || 0,
                        posLike.liquiditySlope || 0,
                        posLike.entropySlope || 0
                    );
                    
                    let tier: 'A' | 'B' | 'C' | 'D' = 'C';
                    const score = posLike.entryScore || 0;
                    if (score >= 40) tier = 'A';
                    else if (score >= 32) tier = 'B';
                    else if (score >= 24) tier = 'C';
                    else tier = 'D';
                    
                    registerHarmonicTrade(
                        posLike.tradeId,
                        posLike.poolAddress,
                        posLike.poolName,
                        tier,
                        baselineSnapshot
                    );
                    
                    logger.info(`[EXECUTION] Recovered position: ${posLike.poolName} ($${posLike.entrySizeUsd.toFixed(2)})`);
                }
            }

            const currentBalance = await capitalManager.getBalance();
            const state = await capitalManager.getFullState();
            
            // Safety filter: remove any positions that are marked as closed
            // This prevents stale DB states from leaking into runtime
            const beforeFilter = this.positions.length;
            this.positions = this.positions.filter(p => !p.closed);
            if (beforeFilter !== this.positions.length) {
                logger.warn(`[EXECUTION] Filtered out ${beforeFilter - this.positions.length} closed positions from recovery`);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FINAL INVARIANT CHECK: Hydrated count MUST equal sealed count
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (this.positions.length !== sealedCount) {
                console.error('');
                console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.error('ğŸš¨ [EXECUTION] FATAL: Position count mismatch after hydration');
                console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.error(`   Sealed Count: ${sealedCount}`);
                console.error(`   Hydrated Count: ${this.positions.length}`);
                console.error('   This is a critical consistency violation â€” fail closed.');
                console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                process.exit(1);
            }
            
            logger.info('[EXECUTION] âœ… Engine initialized (STATEFUL MODE)', {
                availableBalance: `$${currentBalance.toFixed(2)}`,
                lockedBalance: `$${state?.locked_balance?.toFixed(2) || 0}`,
                totalPnL: `$${state?.total_realized_pnl?.toFixed(2) || 0}`,
                recoveredPositions: this.positions.length,
                sealedPositionCount: sealedCount,
            });

            this.initialized = true;
            return true;

        } catch (err: any) {
            logger.error(`[EXECUTION] âŒ Initialization failed: ${err.message}`);
            return false;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATEFUL MODE â€” START/STOP RUNTIME LOOPS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Start all internal runtime loops
     * This makes the engine run continuously, not just when invoked by ScanLoop
     */
    public start(): void {
        if (this.running) {
            logger.warn('[ENGINE] Already running - ignoring start()');
            return;
        }

        logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        logger.info('[ENGINE] Starting internal runtime loops...');
        logger.info('   Engine Mode: STATEFUL');

        let loopCount = 0;

        // Price watcher - updates position prices from pool data
        logger.info('[ENGINE] Starting price watcher...');
        this.priceWatcherTimer = setInterval(() => this.runPriceWatcher(), PRICE_WATCHER_INTERVAL);
        loopCount++;

        // Exit watcher - evaluates exit conditions continuously
        logger.info('[ENGINE] Starting exit watcher...');
        this.exitWatcherTimer = setInterval(() => this.runExitWatcher(), EXIT_WATCHER_INTERVAL);
        loopCount++;

        // Snapshot timer - writes portfolio snapshots
        logger.info('[ENGINE] Starting snapshot timer...');
        this.snapshotTimer = setInterval(() => this.runSnapshotWriter(), SNAPSHOT_INTERVAL);
        loopCount++;

        // PnL drift updater - recalculates unrealized PnL
        logger.info('[ENGINE] Starting PnL drift updater...');
        this.pnlDriftTimer = setInterval(() => this.runPnlDriftUpdater(), PNL_DRIFT_INTERVAL);
        loopCount++;

        // Regime updater - updates regime and migration direction
        logger.info('[ENGINE] Starting regime updater...');
        this.regimeUpdaterTimer = setInterval(() => this.runRegimeUpdater(), REGIME_UPDATER_INTERVAL);
        loopCount++;

        // Bin tracker - tracks bin movements
        logger.info('[ENGINE] Starting bin tracker...');
        this.binTrackerTimer = setInterval(() => this.runBinTracker(), BIN_TRACKER_INTERVAL);
        loopCount++;

        // PnL auditor - reconciles in-memory vs DB PnL
        logger.info('[ENGINE] Starting PnL auditor...');
        this.pnlAuditorTimer = setInterval(() => this.runPnlAuditor(), PNL_AUDITOR_INTERVAL);
        loopCount++;

        this.running = true;
        logger.info(`[ENGINE] âœ… Started ${loopCount} internal loops`);
        logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    }

    /**
     * Stop all internal runtime loops
     * 
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * WARNING: After reconciliation seal, stopping the engine is a FATAL operation
     * for normal runtime. Only allowed during graceful shutdown.
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */
    public stop(): void {
        if (!this.running) {
            logger.warn('[ENGINE] Not running - ignoring stop()');
            return;
        }
        
        // If reconciliation is sealed and we're stopping, this MUST be graceful shutdown
        // Log a warning but allow it (gracefulShutdown is the legitimate caller)
        if (isReconciliationSealed()) {
            logger.warn('[ENGINE] Stopping engine after reconciliation seal (expected only during graceful shutdown)');
        }

        logger.info('[ENGINE] Stopping internal runtime loops...');

        if (this.priceWatcherTimer) {
            clearInterval(this.priceWatcherTimer);
            this.priceWatcherTimer = null;
        }
        if (this.exitWatcherTimer) {
            clearInterval(this.exitWatcherTimer);
            this.exitWatcherTimer = null;
        }
        if (this.snapshotTimer) {
            clearInterval(this.snapshotTimer);
            this.snapshotTimer = null;
        }
        if (this.pnlDriftTimer) {
            clearInterval(this.pnlDriftTimer);
            this.pnlDriftTimer = null;
        }
        if (this.regimeUpdaterTimer) {
            clearInterval(this.regimeUpdaterTimer);
            this.regimeUpdaterTimer = null;
        }
        if (this.binTrackerTimer) {
            clearInterval(this.binTrackerTimer);
            this.binTrackerTimer = null;
        }
        if (this.pnlAuditorTimer) {
            clearInterval(this.pnlAuditorTimer);
            this.pnlAuditorTimer = null;
        }

        this.running = false;
        logger.info('[ENGINE] âœ… All internal loops stopped');
    }

    /**
     * Check if engine is running
     */
    public isRunning(): boolean {
        return this.running;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INTERNAL LOOP IMPLEMENTATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Price watcher loop - updates position prices from telemetry
     */
    private async runPriceWatcher(): Promise<void> {
        if (this.priceWatcherRunning) return;
        this.priceWatcherRunning = true;

        try {
            const openPositions = this.positions.filter(p => !p.closed);
            
            for (const position of openPositions) {
                const poolData = this.poolQueue.find(p => p.address === position.pool);
                if (poolData) {
                    this.updatePositionPrice(position, poolData);
                }
            }
        } catch (err: any) {
            logger.error(`[ENGINE] Price watcher error: ${err.message}`);
        } finally {
            this.priceWatcherRunning = false;
        }
    }

    /**
     * Exit watcher loop - evaluates exit conditions for all positions
     * 
     * CRITICAL: Increments exit watcher cycle counter for MTM staleness detection.
     * Each cycle advances the counter, which triggers MTM cache invalidation when
     * consecutive unchanged values exceed threshold (N=3).
     */
    private async runExitWatcher(): Promise<void> {
        if (this.exitWatcherRunning) return;
        this.exitWatcherRunning = true;
        
        // Increment exit watcher cycle for MTM staleness tracking
        incrementExitWatcherCycle();

        try {
            const openPositions = this.positions.filter(p => !p.closed && p.exitState === 'open');
            
            for (const position of openPositions) {
                const health = this.evaluatePositionHealth(position.id);
                
                if (health.shouldExit) {
                    logger.info(`[ENGINE] Exit watcher triggered exit for ${position.symbol}: ${health.exitReason}`);
                    await this.executeExit(position.id, health.exitReason, 'EXIT_WATCHER');
                }
            }
        } catch (err: any) {
            logger.error(`[ENGINE] Exit watcher error: ${err.message}`);
        } finally {
            this.exitWatcherRunning = false;
        }
    }

    /**
     * Snapshot writer loop - writes portfolio state periodically
     */
    private async runSnapshotWriter(): Promise<void> {
        if (this.snapshotRunning) return;
        this.snapshotRunning = true;

        try {
            const openPositions = this.positions.filter(p => !p.closed);
            const unrealized = openPositions.reduce((sum, p) => sum + p.pnl, 0);
            
            const state = await capitalManager.getFullState();
            if (state) {
                const snapshot = {
                    timestamp: new Date().toISOString(),
                    availableBalance: state.available_balance,
                    lockedBalance: state.locked_balance,
                    totalRealizedPnl: state.total_realized_pnl,
                    unrealizedPnl: unrealized,
                    openPositionCount: openPositions.length,
                    equity: state.available_balance + state.locked_balance + unrealized,
                };
                
                // Log snapshot (actual DB write happens via existing logAction)
                try {
                    await logAction('PORTFOLIO_SNAPSHOT', snapshot);
                } catch {
                    // Ignore snapshot logging errors
                }
            }
        } catch (err: any) {
            logger.error(`[ENGINE] Snapshot writer error: ${err.message}`);
        } finally {
            this.snapshotRunning = false;
        }
    }

    /**
     * PnL drift updater loop - recalculates unrealized PnL for all positions
     */
    private async runPnlDriftUpdater(): Promise<void> {
        if (this.pnlDriftRunning) return;
        this.pnlDriftRunning = true;

        try {
            const openPositions = this.positions.filter(p => !p.closed);
            
            for (const position of openPositions) {
                // PnL is recalculated in updatePositionPrice
                const priceChange = (position.currentPrice - position.entryPrice) / position.entryPrice;
                position.pnlPercent = priceChange;
                position.pnl = priceChange * position.sizeUSD;
            }
        } catch (err: any) {
            logger.error(`[ENGINE] PnL drift updater error: ${err.message}`);
        } finally {
            this.pnlDriftRunning = false;
        }
    }

    /**
     * Regime updater loop - updates regime and migration direction for positions
     */
    private async runRegimeUpdater(): Promise<void> {
        if (this.regimeUpdaterRunning) return;
        this.regimeUpdaterRunning = true;

        try {
            const openPositions = this.positions.filter(p => !p.closed);
            
            for (const position of openPositions) {
                const tier4 = computeTier4Score(position.pool);
                if (tier4 && tier4.valid) {
                    // Update current regime info (entry values stay fixed)
                    const poolData = this.poolQueue.find(p => p.address === position.pool);
                    if (poolData) {
                        poolData.regime = tier4.regime;
                        poolData.migrationDirection = tier4.migrationDirection;
                        poolData.tier4Score = tier4.tier4Score;
                    }
                    
                    // Update position in database with health score
                    // NOTE: regime removed - not in minimal positions schema
                    await updatePositionState(position.id, {
                        healthScore: tier4.tier4Score,
                    });
                }
            }
        } catch (err: any) {
            logger.error(`[ENGINE] Regime updater error: ${err.message}`);
        } finally {
            this.regimeUpdaterRunning = false;
        }
    }

    /**
     * Bin tracker loop - tracks bin movements for all positions
     * Computes bin velocity and acceleration (second-order delta) for exit context
     */
    private async runBinTracker(): Promise<void> {
        if (this.binTrackerRunning) return;
        this.binTrackerRunning = true;

        try {
            const openPositions = this.positions.filter(p => !p.closed);
            const now = Date.now();
            
            for (const position of openPositions) {
                const poolData = this.poolQueue.find(p => p.address === position.pool);
                if (poolData && poolData.activeBin) {
                    const previousBin = position.currentBin;
                    position.currentBin = poolData.activeBin;
                    position.binOffset = Math.abs(poolData.activeBin - position.entryBin);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // SECOND-ORDER DELTA: Compute bin velocity and acceleration
                    // Used as exit context only, NOT a new exit trigger
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (previousBin !== 0 && poolData.activeBin !== previousBin) {
                        const timeDeltaSec = BIN_TRACKER_INTERVAL / 1000;
                        const binDelta = poolData.activeBin - previousBin;
                        const velocity = binDelta / timeDeltaSec; // bins/sec
                        
                        // Get or create velocity history for this position
                        let history = this.binVelocityHistory.get(position.id);
                        if (!history) {
                            history = [];
                            this.binVelocityHistory.set(position.id, history);
                        }
                        
                        // Add new velocity sample
                        history.push({ ts: now, velocity });
                        
                        // Keep only last N samples
                        if (history.length > ExecutionEngine.BIN_VELOCITY_HISTORY_SIZE) {
                            history.shift();
                        }
                        
                        // Compute acceleration if we have at least 2 samples
                        if (history.length >= 2) {
                            const oldest = history[0];
                            const newest = history[history.length - 1];
                            const velocityDelta = newest.velocity - oldest.velocity;
                            const timeDelta = (newest.ts - oldest.ts) / 1000; // seconds
                            
                            if (timeDelta > 0) {
                                const acceleration = velocityDelta / timeDelta; // bins/secÂ²
                                this.binAcceleration.set(position.id, acceleration);
                            }
                        }
                    }
                    
                    // Update position in database if bin changed
                    if (poolData.activeBin !== previousBin) {
                        await updatePositionState(position.id, {
                            currentBin: poolData.activeBin,
                        });
                    }
                    
                    // Log significant bin movements
                    if (Math.abs(poolData.activeBin - previousBin) >= 3) {
                        const accel = this.binAcceleration.get(position.id);
                        const accelStr = accel !== undefined ? ` accel=${accel.toFixed(4)}` : '';
                        logger.info(`[BIN_TRACKER] ${position.symbol} bin moved: ${previousBin} â†’ ${poolData.activeBin} (offset: ${position.binOffset}${accelStr})`);
                    }
                }
            }
            
            // Cleanup: remove acceleration data for closed positions
            for (const posId of this.binAcceleration.keys()) {
                if (!openPositions.find(p => p.id === posId)) {
                    this.binAcceleration.delete(posId);
                    this.binVelocityHistory.delete(posId);
                }
            }
        } catch (err: any) {
            logger.error(`[ENGINE] Bin tracker error: ${err.message}`);
        } finally {
            this.binTrackerRunning = false;
        }
    }
    
    /**
     * Get bin acceleration for a position (exit context only)
     * @returns acceleration in bins/secÂ², or null if not available
     */
    public getBinAcceleration(positionId: string): number | null {
        return this.binAcceleration.get(positionId) ?? null;
    }

    /**
     * PnL Auditor loop - reconciles in-memory PnL against database
     * 
     * Every 5 minutes:
     * 1. Fetch canonical realized PnL from DB
     * 2. Compare with in-memory cached value
     * 3. Log drift if threshold exceeded
     * 4. Auto-correct if needed
     * 5. Run PHANTOM EQUITY sanity check
     */
    private async runPnlAuditor(): Promise<void> {
        if (this.pnlAuditorRunning) return;
        this.pnlAuditorRunning = true;

        try {
            // Reconcile PnL
            const reconciliation = await reconcilePnL(0.01); // $0.01 threshold
            
            if (reconciliation.hasDrift) {
                logger.warn(
                    `[PNL-AUDIT] Drift detected: ` +
                    `inMemory=$${reconciliation.inMemoryRealizedPnL.toFixed(2)} ` +
                    `vs db=$${reconciliation.dbRealizedPnL.toFixed(2)} ` +
                    `drift=$${reconciliation.driftUSD.toFixed(2)}`
                );
                
                // Auto-correct
                const corrected = await correctPnLDrift();
                if (corrected) {
                    const oldValue = this.cachedRealizedPnL;
                    this.cachedRealizedPnL = reconciliation.dbRealizedPnL;
                    logger.info(
                        `[PNL-AUDIT] Corrected in-memory realized PnL from ` +
                        `$${oldValue.toFixed(2)} to $${reconciliation.dbRealizedPnL.toFixed(2)}`
                    );
                }
            } else {
                // Update cache silently
                this.cachedRealizedPnL = reconciliation.dbRealizedPnL;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHANTOM EQUITY SANITY CHECK
            // Ensures Net Equity <= Starting Capital + maxUnrealized + epsilon
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            await this.runPhantomEquityCheck();
            
        } catch (err: any) {
            logger.error(`[ENGINE] PnL auditor error: ${err.message}`);
        } finally {
            this.pnlAuditorRunning = false;
        }
    }
    
    /**
     * Phantom Equity Check - Critical accounting guardrail
     * 
     * Detects if net equity exceeds what's mathematically possible:
     *   Net Equity <= Starting Capital + Max Unrealized PnL + epsilon
     * 
     * If violated, logs CRITICAL error - indicates double-counting or reset artifacts.
     */
    private async runPhantomEquityCheck(): Promise<void> {
        try {
            const startingCapital = getStartingCapitalThisRun();
            if (startingCapital <= 0) return; // Run epoch not initialized
            
            const openPositions = this.positions.filter(p => !p.closed);
            const unrealizedPnL = openPositions.reduce((sum, p) => sum + p.pnl, 0);
            
            // Max unrealized = current unrealized + reasonable buffer for price movement
            // Use 10% buffer for normal market volatility
            const maxUnrealizedPnL = Math.abs(unrealizedPnL) * 1.1 + 10; // Add $10 buffer
            
            // Calculate actual net equity
            const state = await capitalManager.getFullState();
            if (!state) return;
            
            const netEquity = state.available_balance + state.locked_balance + unrealizedPnL;
            
            // Run sanity check
            const check = sanityCheckEquity(netEquity, startingCapital, maxUnrealizedPnL, 1.0);
            
            if (!check.valid) {
                logger.error(`[PHANTOM-EQUITY-CHECK] ${check.error}`);
                logger.error(
                    `[PHANTOM-EQUITY-CHECK] Breakdown: ` +
                    `Available=$${state.available_balance.toFixed(2)} ` +
                    `Locked=$${state.locked_balance.toFixed(2)} ` +
                    `Unrealized=$${unrealizedPnL.toFixed(2)} ` +
                    `RunID=${getActiveRunId()}`
                );
            }
            
        } catch (err: any) {
            // Don't let sanity check errors break the auditor
            logger.warn(`[PHANTOM-EQUITY-CHECK] Error during check: ${err.message}`);
        }
    }

    /**
     * Convert a Trade record to a Position object
     */
    private tradeToPosition(trade: Trade): Position | null {
        return {
            id: trade.id,
            pool: trade.pool,
            symbol: trade.poolName,
            entryPrice: trade.entryPrice,
            currentPrice: trade.entryPrice,
            sizeUSD: trade.size,
            pnl: 0,
            pnlPercent: 0,
            bins: trade.entryBin ? [trade.entryBin] : [],
            openedAt: trade.timestamp,
            closed: false,
            
            entryBin: trade.entryBin || 0,
            currentBin: trade.entryBin || 0,
            binOffset: 0,
            
            entryFeeIntensity: 0,
            entrySwapVelocity: trade.velocity,
            entry3mFeeIntensity: 0,
            
            entryTier4Score: trade.score,
            entryRegime: 'NEUTRAL' as MarketRegime,
            entryMigrationDirection: 'neutral' as MigrationDirection,
            entryVelocitySlope: trade.velocitySlope,
            entryLiquiditySlope: trade.liquiditySlope,
            entryEntropySlope: trade.entropySlope,
            entryBinWidth: { min: 8, max: 18, label: 'medium' as const },
            entryThreshold: 32,
            exitThreshold: 22,
            
            exitState: trade.exitState || 'open',
            pendingExit: trade.pendingExit || false,
        };
    }
    
    /**
     * Convert PositionLike (from positions table) to internal Position format
     * 
     * CRITICAL: This is used for hydration from sealed position IDs.
     * The positions table is the SINGLE SOURCE OF TRUTH for open positions.
     */
    private positionLikeToPosition(posLike: PositionLike): Position | null {
        return {
            id: posLike.tradeId,
            pool: posLike.poolAddress,
            symbol: posLike.poolName,
            entryPrice: posLike.entryPrice,
            currentPrice: posLike.entryPrice,
            sizeUSD: posLike.entrySizeUsd,
            pnl: 0,
            pnlPercent: 0,
            bins: posLike.entryBin ? [posLike.entryBin] : [],
            openedAt: posLike.entryTime,
            closed: false,
            
            entryBin: posLike.entryBin || 0,
            currentBin: posLike.currentBin || posLike.entryBin || 0,
            binOffset: 0,
            
            entryFeeIntensity: 0,
            entrySwapVelocity: 0,
            entry3mFeeIntensity: 0,
            
            entryTier4Score: posLike.entryScore || 0,
            entryRegime: (posLike.regime as MarketRegime) || 'NEUTRAL',
            entryMigrationDirection: (posLike.migrationDirection as MigrationDirection) || 'neutral',
            entryVelocitySlope: posLike.velocitySlope || 0,
            entryLiquiditySlope: posLike.liquiditySlope || 0,
            entryEntropySlope: posLike.entropySlope || 0,
            entryBinWidth: { min: 8, max: 18, label: 'medium' as const },
            entryThreshold: 32,
            exitThreshold: 22,
            
            exitState: 'open',
            pendingExit: false,
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API â€” INVOKED BY SCANLOOP ONLY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Place positions in pools that pass Tier 4 entry conditions.
     * Called by ScanLoop during each cycle.
     */
    public async placePools(pools: ScoredPool[]): Promise<void> {
        if (!this.initialized) {
            logger.warn('[EXECUTION] Engine not initialized - call initialize() first');
            return;
        }

        logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        logger.info('[EXECUTION] placePools called (Tier 4)');
        logger.info(`[EXECUTION] Pool count: ${pools.length}`);

        // Get current capital from database
        let currentCapital: number;
        try {
            currentCapital = await capitalManager.getBalance();
        } catch (err: any) {
            logger.error(`[EXECUTION] Failed to get capital: ${err.message}`);
            return;
        }

        if (currentCapital <= 0) {
            logger.warn(`[EXECUTION] No available capital: $${currentCapital.toFixed(2)}`);
            return;
        }

        // Enrich pools with Tier 4 data and sort by score
        const enrichedPools = pools.map(pool => this.enrichWithTier4(pool));
        const sorted = [...enrichedPools].sort((a, b) => (b.tier4Score ?? 0) - (a.tier4Score ?? 0));
        this.poolQueue = sorted;

        // Get current total exposure
        const currentTotalExposure = this.positions
            .filter(p => !p.closed)
            .reduce((sum, p) => sum + p.sizeUSD, 0);

        // Filter for Tier 4 entry conditions
        const openPoolAddresses = new Set(
            this.positions.filter(p => !p.closed).map(p => p.pool)
        );
        
        const eligiblePools: ScoredPool[] = [];
        
        for (const pool of sorted) {
            if (openPoolAddresses.has(pool.address)) {
                continue;
            }
            
            const entryCheck = this.checkTier4EntryConditions(pool);
            
            if (entryCheck.canEnter) {
                eligiblePools.push(pool);
                logTier4Cycle(pool.address);
                logger.info(`[EXECUTION] âœ“ ${pool.address.slice(0, 8)}... passes Tier 4 entry`);
            } else {
                if (entryCheck.blockReason) {
                    logEntryBlock(pool.address, entryCheck.blockReason);
                }
                logger.info(`[EXECUTION] âœ— ${pool.address.slice(0, 8)}... blocked: ${entryCheck.blockReason || 'threshold not met'}`);
            }
        }

        // Calculate open slots
        const openPositionCount = this.positions.filter(p => !p.closed).length;
        const slotsAvailable = this.maxConcurrentPools - openPositionCount;

        if (slotsAvailable <= 0) {
            logger.info('[EXECUTION] No slots available for new positions');
            return;
        }

        // Select top eligible pools
        const poolsToEnter = eligiblePools.slice(0, slotsAvailable);

        if (poolsToEnter.length === 0) {
            logger.info('[EXECUTION] No pools pass Tier 4 entry conditions');
            return;
        }

        // Enter each pool with Tier 4 sizing
        for (const pool of poolsToEnter) {
            const tier4 = computeTier4Score(pool.address);
            if (!tier4 || !tier4.valid) continue;
            
            const volatility = this.estimateVolatility(pool);
            const sizing = calcEntrySize(
                tier4.tier4Score, 
                volatility, 
                currentCapital,
                tier4.regime
            );
            
            if (sizing.size > 0) {
                const exposureCheck = canAddPosition(sizing.size, currentTotalExposure, currentCapital);
                
                if (exposureCheck.allowed) {
                    await this.executeEntry(pool, sizing.size, tier4);
                } else {
                    logger.info(`[EXECUTION] Entry blocked by exposure: ${exposureCheck.reason}`);
                }
            }
        }

        logger.info('[EXECUTION] placePools complete', {
            entered: poolsToEnter.filter(p => 
                this.positions.some(pos => pos.pool === p.address && !pos.closed)
            ).length,
            totalOpen: this.positions.filter(p => !p.closed).length,
        });
    }

    /**
     * Execute a single entry. Called by ScanLoop.
     * 
     * DB-FIRST FLOW:
     * 1. Create trade input (no ID)
     * 2. Save to DB â†’ get DB-generated ID
     * 3. Allocate capital with DB-generated ID
     * 4. Register trade in memory
     */
    public async executeEntry(pool: ScoredPool, sizeUSD: number, tier4?: Tier4Score): Promise<boolean> {
        if (!tier4) {
            tier4 = computeTier4Score(pool.address) ?? undefined;
            if (!tier4 || !tier4.valid) {
                logger.warn(`[EXECUTION] Cannot enter ${pool.address.slice(0, 8)}... - no valid Tier4 score`);
                return false;
            }
        }
        
        // Assign risk tier based on score
        const riskTier = assignRiskTier(tier4.tier4Score);
        const leverage = calculateLeverage(tier4.tier4Score, riskTier);
        
        // Create execution data for true fill price tracking
        const entryPrice = this.binToPrice(pool.activeBin);
        const executionData = createDefaultExecutionData(sizeUSD, entryPrice);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CREATE TRADE INPUT (NO ID - database generates it)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const tradeInput: TradeInput = createTradeInput(
            {
                address: pool.address,
                name: `${pool.tokenA.symbol}/${pool.tokenB.symbol}`,
                currentPrice: entryPrice,
                score: tier4.tier4Score,
                liquidity: pool.liquidityUSD,
                velocity: 0,
            },
            sizeUSD,
            'standard',
            {
                entropy: 0,
                velocitySlope: tier4.velocitySlope,
                liquiditySlope: tier4.liquiditySlope,
                entropySlope: tier4.entropySlope,
            },
            executionData,
            riskTier,
            leverage,
            pool.activeBin
        );

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DB-FIRST: Save to database FIRST, get DB-generated ID
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let dbGeneratedId: string;
        try {
            dbGeneratedId = await saveTradeToDB(tradeInput);
            
            // Log DB-assigned ID
            logger.info(`[TRADE-ID] Assigned from DB: ${dbGeneratedId}`);
            
        } catch (err: any) {
            logger.error(`[EXECUTION] Trade persistence failed: ${err.message}`);
            // No capital was allocated yet, so no cleanup needed
            return false;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CREATE FULL TRADE OBJECT WITH DB-ASSIGNED ID
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const trade: Trade = {
            ...tradeInput,
            id: dbGeneratedId,
        };

        // Log the assigned ID
        logger.info(`[ID-GEN] Trade ID assigned from DB`, {
            tradeId: trade.id.slice(0, 8),
            pool: pool.address.slice(0, 8),
            timestamp: Date.now(),
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALLOCATE CAPITAL (AFTER DB insert - use DB-generated ID)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        try {
            const allocated = await capitalManager.allocate(trade.id, sizeUSD);
            if (!allocated) {
                logger.warn(`[EXECUTION] Entry blocked: insufficient capital for $${sizeUSD.toFixed(2)}`);
                // Trade already in DB but we couldn't allocate capital
                // Mark trade as cancelled in DB
                try {
                    const { supabase } = await import('../db/supabase');
                    await supabase.from('trades').update({ 
                        status: 'cancelled',
                        exit_reason: 'INSUFFICIENT_CAPITAL'
                    }).eq('id', trade.id);
                } catch {
                    logger.error(`[DB-ERROR] Failed to cancel trade ${trade.id.slice(0, 8)}... after capital allocation failure`);
                }
                return false;
            }
        } catch (err: any) {
            logger.error(`[EXECUTION] Capital allocation failed: ${err.message}`);
            // Trade already in DB - mark as cancelled
            try {
                const { supabase } = await import('../db/supabase');
                await supabase.from('trades').update({ 
                    status: 'cancelled',
                    exit_reason: 'CAPITAL_ALLOCATION_ERROR'
                }).eq('id', trade.id);
            } catch {
                logger.error(`[DB-ERROR] Failed to cancel trade ${trade.id.slice(0, 8)}... after capital error`);
            }
            return false;
        }

        // Register in memory
        registerTrade(trade);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PERSIST TO POSITIONS TABLE
        // Trade already in trades table, now write to positions for lifecycle tracking
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        try {
            await persistTradeEntry(trade);
        } catch (persistErr: unknown) {
            const errorMsg = persistErr instanceof Error ? persistErr.message : String(persistErr);
            logger.error(`[DB-ERROR] ${JSON.stringify({
                op: 'PERSIST_TRADE_ENTRY',
                id: trade.id,
                pool: pool.address.slice(0, 8),
                errorMessage: errorMsg,
                action: 'ABORTING_TRADE - position not persisted',
            })}`);
            
            // Unregister trade from memory since positions table failed
            unregisterTrade(trade.id);
            
            // Release capital back since we're aborting
            await releaseCapitalLock(trade.id);
            
            // Mark trade as cancelled in DB
            try {
                const { supabase } = await import('../db/supabase');
                await supabase.from('trades').update({ 
                    status: 'cancelled',
                    exit_reason: 'POSITION_PERSIST_FAILED'
                }).eq('id', trade.id);
            } catch {
                // Already logged
            }
            
            return false;
        }

        // Calculate bin cluster
        const binWidth = tier4.binWidth;
        const halfWidth = Math.floor((binWidth.min + binWidth.max) / 4);
        const bins = this.calculateBinRange(pool.activeBin, halfWidth);

        // Get current microstructure metrics
        const metrics = pool.microMetrics || computeMicrostructureMetrics(pool.address);
        
        // Get 3-minute fee intensity
        const swaps3m = getSwapHistory(pool.address, 3 * 60 * 1000);
        const history = getPoolHistory(pool.address);
        const latestLiquidity = history.length > 0 ? history[history.length - 1].liquidityUSD : 0;
        const fees3m = swaps3m.reduce((sum, s) => sum + s.feePaid, 0);
        const entry3mFeeIntensity = latestLiquidity > 0 ? fees3m / latestLiquidity : 0;

        const position: Position = {
            id: trade.id,
            pool: pool.address,
            symbol: `${pool.tokenA.symbol}/${pool.tokenB.symbol}`,
            entryPrice,
            currentPrice: entryPrice,
            sizeUSD,
            pnl: 0,
            pnlPercent: 0,
            bins,
            openedAt: Date.now(),
            closed: false,
            
            entryBin: pool.activeBin,
            currentBin: pool.activeBin,
            binOffset: 0,
            
            entryFeeIntensity: metrics?.feeIntensity ?? 0,
            entrySwapVelocity: metrics?.swapVelocity ?? 0,
            entry3mFeeIntensity,
            
            entryTier4Score: tier4.tier4Score,
            entryRegime: tier4.regime,
            entryMigrationDirection: tier4.migrationDirection,
            entryVelocitySlope: tier4.velocitySlope,
            entryLiquiditySlope: tier4.liquiditySlope,
            entryEntropySlope: tier4.entropySlope,
            entryBinWidth: tier4.binWidth,
            entryThreshold: tier4.entryThreshold,
            exitThreshold: tier4.exitThreshold,
            
            exitState: 'open',
            pendingExit: false,
        };

        this.positions.push(position);
        
        // Record baseline for this pool
        recordEntryBaseline(pool.address);
        
        // Register with telemetry service
        const binPosition: BinFocusedPosition = {
            poolId: pool.address,
            entryBin: pool.activeBin,
            entryTime: Date.now(),
            entryFeeIntensity: metrics?.feeIntensity ?? 0,
            entrySwapVelocity: metrics?.swapVelocity ?? 0,
            entry3mFeeIntensity,
            entry3mSwapVelocity: metrics?.rawSwapCount ? metrics.rawSwapCount / 180 : 0,
            entryTier4Score: tier4.tier4Score,
            entryRegime: tier4.regime,
            entryMigrationDirection: tier4.migrationDirection,
            entryVelocitySlope: tier4.velocitySlope,
            entryLiquiditySlope: tier4.liquiditySlope,
            entryEntropySlope: tier4.entropySlope,
        };
        registerPosition(binPosition);

        // Register for harmonic monitoring
        const baselineSnapshot = createMicroMetricsSnapshot(
            Date.now(),
            metrics?.binVelocity ? metrics.binVelocity / 100 : 0.05,
            metrics?.swapVelocity ? metrics.swapVelocity / 100 : 0.1,
            0,
            metrics?.poolEntropy ?? 0.7,
            metrics?.feeIntensity ? metrics.feeIntensity / 100 : 0.02,
            tier4.velocitySlope,
            tier4.liquiditySlope,
            tier4.entropySlope
        );
        
        registerHarmonicTrade(
            trade.id,
            pool.address,
            `${pool.tokenA.symbol}/${pool.tokenB.symbol}`,
            riskTier,
            baselineSnapshot
        );

        // Log entry to database
        try {
            await logAction('ENTRY', {
                tradeId: trade.id,
                poolAddress: pool.address,
                poolName: `${pool.tokenA.symbol}/${pool.tokenB.symbol}`,
                entry_price: entryPrice,
                entry_amount_base: executionData.netReceivedBase,
                entry_amount_quote: executionData.netReceivedQuote,
                entry_value_usd: executionData.entryAssetValueUsd,
                size: sizeUSD,
                bin: pool.activeBin,
                riskTier,
                leverage,
                regime: tier4.regime,
                microMetrics: {
                    velocitySlope: tier4.velocitySlope,
                    liquiditySlope: tier4.liquiditySlope,
                    entropySlope: tier4.entropySlope,
                },
            });
        } catch (logErr) {
            logger.warn(`[EXECUTION] Failed to log ENTRY to database: ${logErr}`);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STRUCTURED TRADE-ENTRY LOG â€” Tier-4 Execution Cost Semantics
        // All fee/slippage fields explicitly labeled as entry-side costs
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        logTradeEntry({
            positionId: trade.id,
            poolId: pool.address,
            baseToken: pool.tokenA.symbol,
            quoteToken: pool.tokenB.symbol,
            side: 'LP_ADD',
            notionalSizeUSD: sizeUSD,
            baseAmount: executionData.netReceivedBase,
            quoteAmount: executionData.netReceivedQuote,
            entryPrice: entryPrice,
            entryTime: new Date().toISOString(),
            capitalDebited: sizeUSD,
            // Explicit entry-side costs (Tier-4 semantics)
            entryFeesUSD: executionData.entryFeesPaid,
            entrySlippageUSD: executionData.entrySlippageUsd,
            riskTier: riskTier,
            regime: tier4.regime,
        });

        const currentCapital = await capitalManager.getBalance();
        logger.info(
            `[POSITION] ENTRY size=${((sizeUSD / (currentCapital + sizeUSD)) * 100).toFixed(1)}% ` +
            `wallet=$${currentCapital.toFixed(0)} ` +
            `amount=$${sizeUSD.toFixed(2)} ` +
            `symbol=${position.symbol} ` +
            `regime=${tier4.regime}`
        );

        return true;
    }

    /**
     * Execute a single exit. Called by ScanLoop.
     * This is the SINGLE entry point for all exit requests.
     */
    public async executeExit(positionId: string, reason: string, caller: string = 'SCAN_LOOP'): Promise<boolean> {
        const position = this.positions.find(p => p.id === positionId);
        if (!position) {
            logger.warn(`[EXIT_AUTH] Position ${positionId.slice(0, 8)}... not found - ignoring exit request from ${caller}`);
            return false;
        }
        
        return this.exitPositionInternal(position, reason, caller);
    }

    /**
     * Evaluate position health and return exit recommendation.
     * Called by ScanLoop to decide whether to exit.
     * Engine does NOT execute - it only advises.
     */
    public evaluatePositionHealth(positionId: string): PositionHealthEvaluation {
        const position = this.positions.find(p => p.id === positionId);
        
        if (!position || position.closed) {
            return {
                positionId,
                shouldExit: false,
                exitReason: '',
                exitType: 'NONE',
            };
        }

        // Update position price from pool queue
        const poolData = this.poolQueue.find(p => p.address === position.pool);
        if (poolData) {
            this.updatePositionPrice(position, poolData);
        }

        // Check harmonic stops
        const harmonicDecision = this.evaluateHarmonicStopForPosition(position);
        
        if (harmonicDecision && harmonicDecision.type === 'FULL_EXIT') {
            return {
                positionId,
                shouldExit: true,
                exitReason: `HARMONIC_EXIT: ${harmonicDecision.reason}`,
                exitType: 'HARMONIC',
                harmonicDecision,
            };
        }

        // Check Tier 4 exit conditions
        const tier4Eval = this.evaluateTier4Exit(position.pool, position);
        
        if (tier4Eval.shouldExit) {
            return {
                positionId,
                shouldExit: true,
                exitReason: tier4Eval.reason,
                exitType: 'TIER4',
                tier4Eval,
            };
        }

        return {
            positionId,
            shouldExit: false,
            exitReason: '',
            exitType: 'NONE',
            tier4Eval,
        };
    }

    /**
     * Get current portfolio snapshot.
     * 
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * DB-GROUND-TRUTH: Position counts and locked capital are derived from DB
     * In-memory positions are used ONLY for unrealized PnL calculation
     * This ensures crash-safe, consistent portfolio status after restart
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */
    public async getPortfolioStatus(): Promise<PortfolioSnapshot> {
        const openPositions = this.positions.filter(p => !p.closed);
        const unrealized = openPositions.reduce((sum, p) => sum + p.pnl, 0);
        
        let capital = this.initialCapital;
        let lockedCapital = 0;
        let totalRealized = 0;
        let dbOpenCount = 0;
        let dbClosedCount = 0;

        try {
            const state = await capitalManager.getFullState();
            if (state) {
                capital = state.available_balance;
                lockedCapital = state.locked_balance;
                totalRealized = state.total_realized_pnl;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DB-DERIVED POSITION COUNTS (crash-safe, consistent after restart)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const dbCounts = await getDbPositionCounts();
            dbOpenCount = dbCounts.openCount;
            dbClosedCount = dbCounts.closedCount;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // INVARIANT FIX: If DB says 0 open positions, locked must be 0
            // This prevents "Locked > 0 with Open Pos = 0" inconsistency
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (dbOpenCount === 0 && lockedCapital > 0.01) {
                logger.warn(
                    `[PORTFOLIO-INVARIANT] DB has 0 open positions but locked=$${lockedCapital.toFixed(2)}. ` +
                    `Releasing orphaned locked capital.`
                );
                // Release the orphaned locked capital to available
                capital = capital + lockedCapital;
                lockedCapital = 0;
                
                // Update DB to fix the inconsistency
                const { supabase } = await import('../db/supabase');
                await supabase
                    .from('capital_state')
                    .update({
                        available_balance: capital,
                        locked_balance: 0,
                        updated_at: new Date().toISOString(),
                    })
                    .eq('id', 1);
            }
        } catch {
            // Use defaults
        }

        const totalEquity = capital + lockedCapital;
        const equity = totalEquity + unrealized;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RETURN DB-DERIVED COUNTS, NOT IN-MEMORY COUNTS
        // In-memory openPositions are still returned for display details
        // but the COUNT comes from DB for correctness
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        return {
            capital,
            lockedCapital,
            totalEquity,
            openPositions: [...openPositions],
            closedPositions: [...this.closedPositions],
            realized: totalRealized,
            unrealized,
            equity,
            ts: new Date(),
            // Inject DB counts as metadata (for portfolio status display)
            dbOpenCount,
            dbClosedCount,
        } as PortfolioSnapshot & { dbOpenCount: number; dbClosedCount: number };
    }

    /**
     * Force close all positions.
     */
    public async closeAll(reason: string = 'MANUAL_CLOSE'): Promise<void> {
        logger.info('[EXECUTION] Closing all positions', { reason });

        for (const position of this.positions) {
            if (!position.closed) {
                await this.exitPositionInternal(position, reason, 'CLOSE_ALL');
            }
        }
    }

    /**
     * Get open position count.
     */
    public getOpenPositionCount(): number {
        return this.positions.filter(p => !p.closed).length;
    }

    /**
     * Get all open positions (for ScanLoop to iterate)
     */
    public getOpenPositions(): Position[] {
        return this.positions.filter(p => !p.closed);
    }

    /**
     * Get total equity.
     */
    public async getEquity(): Promise<number> {
        const unrealized = this.positions
            .filter(p => !p.closed)
            .reduce((sum, p) => sum + p.pnl, 0);
        
        try {
            const equity = await capitalManager.getEquity();
            return equity + unrealized;
        } catch {
            return this.initialCapital + unrealized;
        }
    }

    /**
     * Update pool queue for position price updates.
     * Called by ScanLoop before evaluating positions.
     */
    public updatePoolQueue(pools: ScoredPool[]): void {
        this.poolQueue = pools;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIER 4 ENTRY CONDITIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    private enrichWithTier4(pool: ScoredPool): ScoredPool {
        const tier4 = computeTier4Score(pool.address);
        
        return {
            ...pool,
            tier4,
            tier4Score: tier4?.tier4Score ?? 0,
            regime: tier4?.regime ?? 'NEUTRAL',
            migrationDirection: tier4?.migrationDirection ?? 'neutral',
            entryThreshold: tier4?.entryThreshold ?? 32,
            exitThreshold: tier4?.exitThreshold ?? 22,
            binWidth: tier4?.binWidth,
            velocitySlope: tier4?.velocitySlope ?? 0,
            liquiditySlope: tier4?.liquiditySlope ?? 0,
            entropySlope: tier4?.entropySlope ?? 0,
        };
    }

    private checkTier4EntryConditions(pool: ScoredPool): { 
        canEnter: boolean; 
        blockReason?: string;
    } {
        const evaluation = evaluateTier4Entry({ 
            address: pool.address, 
            name: pool.tokenA.symbol + '/' + pool.tokenB.symbol 
        } as any);
        
        return {
            canEnter: evaluation.canEnter,
            blockReason: evaluation.blocked ? evaluation.blockReason : undefined,
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIER 4 EXIT EVALUATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    public evaluateTier4Exit(poolId: string, position: Position): Tier4ExitEvaluation {
        const tier4 = computeTier4Score(poolId);
        const metrics = computeMicrostructureMetrics(poolId);
        
        const result: Tier4ExitEvaluation = {
            shouldExit: false,
            reason: '',
            tier4Score: tier4?.tier4Score ?? 0,
            exitThreshold: tier4?.exitThreshold ?? 22,
            regime: tier4?.regime ?? 'NEUTRAL',
            feeIntensityDrop: 0,
            migrationReversal: false,
        };
        
        if (!tier4 || !tier4.valid || !metrics) {
            return result;
        }
        
        // Check if score below exit threshold
        if (tier4.tier4Score < tier4.exitThreshold) {
            result.shouldExit = true;
            result.reason = `Tier4 score ${tier4.tier4Score.toFixed(1)} < exit threshold ${tier4.exitThreshold} (${tier4.regime})`;
            return result;
        }
        
        // Check migration reversal
        const history = getPoolHistory(poolId);
        if (history.length >= 2) {
            const latest = history[history.length - 1];
            const previous = history[history.length - 2];
            const timeDeltaSec = (latest.fetchedAt - previous.fetchedAt) / 1000;
            const liquiditySlopePerMin = timeDeltaSec > 0 
                ? ((latest.liquidityUSD - previous.liquidityUSD) / latest.liquidityUSD) * (60 / timeDeltaSec)
                : 0;
            
            const migrationBlock = checkMigrationBlock(position.entryMigrationDirection, liquiditySlopePerMin);
            
            if (migrationBlock.blocked) {
                result.shouldExit = true;
                result.reason = `Migration reversal: ${migrationBlock.reason}`;
                result.migrationReversal = true;
                return result;
            }
        }
        
        // Check fee intensity collapse
        if (position.entryFeeIntensity > 0) {
            const feeIntensityDrop = (position.entryFeeIntensity - metrics.feeIntensity) / position.entryFeeIntensity;
            result.feeIntensityDrop = feeIntensityDrop;
            
            if (feeIntensityDrop >= EXIT_THRESHOLDS.feeIntensityCollapse) {
                result.shouldExit = true;
                result.reason = `Fee intensity collapse ${(feeIntensityDrop * 100).toFixed(1)}% >= ${EXIT_THRESHOLDS.feeIntensityCollapse * 100}%`;
                return result;
            }
        }
        
        return result;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HARMONIC STOP EVALUATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    private evaluateHarmonicStopForPosition(position: Position): HarmonicDecision | null {
        const metrics = computeMicrostructureMetrics(position.pool);
        if (!metrics) return null;
        
        const slopes = getMomentumSlopes(position.pool);
        if (!slopes || !slopes.valid) return null;
        
        const history = getPoolHistory(position.pool);
        if (history.length < 2) return null;
        
        const latest = history[history.length - 1];
        const previous = history[history.length - 2];
        const liquidityFlowPct = previous.liquidityUSD > 0
            ? (latest.liquidityUSD - previous.liquidityUSD) / previous.liquidityUSD
            : 0;
        
        const currentSnapshot = createMicroMetricsSnapshot(
            Date.now(),
            metrics.binVelocity / 100,
            metrics.swapVelocity / 100,
            liquidityFlowPct,
            metrics.poolEntropy,
            metrics.feeIntensity / 100,
            slopes.velocitySlope,
            slopes.liquiditySlope,
            slopes.entropySlope
        );
        
        const entryBaseline = getEntryBaseline(position.pool);
        
        let baselineSnapshot: MicroMetricsSnapshot;
        if (entryBaseline) {
            baselineSnapshot = createMicroMetricsSnapshot(
                position.openedAt,
                position.entrySwapVelocity,
                position.entrySwapVelocity,
                0,
                0.7,
                position.entryFeeIntensity,
                entryBaseline.velocitySlope,
                entryBaseline.liquiditySlope,
                entryBaseline.entropySlope
            );
        } else {
            baselineSnapshot = createMicroMetricsSnapshot(
                position.openedAt,
                position.entrySwapVelocity,
                position.entrySwapVelocity,
                0,
                0.7,
                position.entryFeeIntensity,
                position.entryVelocitySlope,
                position.entryLiquiditySlope,
                position.entryEntropySlope
            );
        }
        
        let tier: 'A' | 'B' | 'C' | 'D';
        if (position.entryTier4Score >= 40) tier = 'A';
        else if (position.entryTier4Score >= 32) tier = 'B';
        else if (position.entryTier4Score >= 24) tier = 'C';
        else tier = 'D';
        
        const ctx = createHarmonicContext(
            position.id,
            position.pool,
            position.symbol,
            tier,
            position.openedAt,
            position.entryPrice,
            position.sizeUSD,
            baselineSnapshot
        );
        
        return evaluateHarmonicStop(ctx, currentSnapshot);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXIT LOGIC - SINGLE EXIT AUTHORITY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    private async exitPositionInternal(position: Position, reason: string, caller: string): Promise<boolean> {
        // Guard checks
        if (position.closed) {
            logger.info(`[GUARD] Skipping duplicate exit for trade ${position.id.slice(0, 8)}... â€” already closed`);
            return false;
        }

        if (position.exitState !== 'open') {
            logger.info(`[GUARD] Skipping duplicate exit for trade ${position.id.slice(0, 8)}... â€” already ${position.exitState}`);
            return false;
        }

        if (position.pendingExit) {
            logger.info(`[GUARD] Skipping duplicate exit for trade ${position.id.slice(0, 8)}... â€” exit pending`);
            return false;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MTM VALUATION â€” COMPUTE TRUE POSITION VALUE FOR EXIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const poolData = this.poolQueue.find(p => p.address === position.pool);
        const poolState: PoolStateForMTM = {
            address: position.pool,
            name: position.symbol,
            activeBin: poolData?.activeBin ?? position.currentBin,
            currentPrice: position.currentPrice,
            liquidityUSD: poolData?.liquidityUSD ?? 0,
            feeIntensity: poolData?.microMetrics?.feeIntensity ?? 0,
            swapVelocity: poolData?.microMetrics?.swapVelocity ?? 0,
        };
        
        const priceFeed: PriceFeed = createDefaultPriceFeed(poolState);
        const positionForMtm = createPositionForMtm(
            position.id,
            position.pool,
            position.entryPrice,
            position.sizeUSD,
            position.entryBin,
            position.openedAt,
            position.entryFeeIntensity
        );
        
        const mtm = computeExitMtmUsd(positionForMtm, poolState, priceFeed);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MTM ERROR FORCED EXIT â€” Bypass suppression when MTM is persistently broken
        // If consecutive MTM errors exceed threshold (50+), force exit immediately
        // This prevents infinite suppression loops when pricing data is invalid
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const mtmErrorCheck = shouldForceExitDueToMtmError();
        if (mtmErrorCheck.shouldForceExit) {
            // Upgrade reason to MTM_ERROR_EXIT (a RISK exit type)
            reason = `MTM_ERROR_EXIT: ${mtmErrorCheck.consecutiveErrors} consecutive MTM errors`;
            logger.warn(
                `[MTM-ERROR-EXIT] Forcing exit for ${position.symbol} trade=${position.id.slice(0, 8)}... ` +
                `errors=${mtmErrorCheck.consecutiveErrors} threshold=${mtmErrorCheck.threshold}`
            );
            // Note: MTM_ERROR_EXIT is in RISK_EXIT_TYPES, so it will bypass suppression below
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXIT HYSTERESIS â€” SUPPRESS NOISE EXITS IF NOT READY
        // NEVER suppress risk exits (kill switch, regime flip, etc.)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!isRiskExit(reason)) {
            const suppressionResult = shouldSuppressNoiseExit(
                {
                    tradeId: position.id,
                    poolName: position.symbol,
                    entryTime: position.openedAt,
                    entryNotionalUsd: position.sizeUSD,
                },
                mtm,
                reason
            );
            
            recordSuppressionCheck(suppressionResult, reason);
            
            if (suppressionResult.suppress) {
                logger.info(
                    `[EXIT-SUPPRESS] ${position.symbol} reason=${suppressionResult.reason} ` +
                    `${suppressionResult.details}`
                );
                return false; // Exit suppressed - position stays open
            }
        }

        // Acquire exit lock
        if (!acquireExitLock(position.id, caller)) {
            return false;
        }

        position.pendingExit = true;
        position.exitState = 'closing';

        logger.info(`[EXIT_AUTH] Exit granted for trade ${position.id.slice(0, 8)}... via ${caller}`);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCULATE EXIT VALUES FROM MTM â€” TIER-0 CORRECTNESS FIX
        // exitAssetValueUsd MUST equal mtmValueUsd at exit-time
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // MTM-based exit value (includes token value + accrued fees)
        const exitAssetValueUsd = mtm.mtmValueUsd;
        
        // Gross PnL from MTM (NOT the old priceChange * sizeUSD)
        const grossPnl = mtm.unrealizedPnlUsd;
        
        // Entry costs (from entry notional using default 0.3% fee, 0.1% slippage model)
        const entryFeesUsd = position.sizeUSD * 0.003;
        const entrySlippageUsd = position.sizeUSD * 0.001;
        
        // Exit costs (from MTM exit value using same model)
        const exitFeesPaid = exitAssetValueUsd * 0.003;
        const exitSlippageUsd = exitAssetValueUsd * 0.001;
        
        // Totals for Tier-4 explicit breakdown
        const totalFeesUsd = entryFeesUsd + exitFeesPaid;
        const totalSlippageUsd = entrySlippageUsd + exitSlippageUsd;
        
        // Log MTM-based PnL for observability
        logPnlUsdWithMtm(position.id, position.symbol, mtm, exitFeesPaid, entryFeesUsd);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UPDATE TRADES TABLE - Returns authoritative NET PnL
        // Net PnL = (exitValue - entryValue) - allFees - allSlippage
        // This single value is used for: [PNL_USD], [CAPITAL], [TRADE_EXIT], positions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let netPnlUsd: number;
        try {
            netPnlUsd = await updateTradeExitInDB(position.id, {
                exitPrice: position.currentPrice,
                exitAssetValueUsd,
                exitFeesPaid,
                exitSlippageUsd,
            }, reason);
            // Round to 2 decimals for consistency
            netPnlUsd = Math.round(netPnlUsd * 100) / 100;
        } catch (err: any) {
            logger.error(`[EXECUTION] Failed to update trade exit: ${err.message}`);
            releaseExitLock(position.id);
            position.pendingExit = false;
            position.exitState = 'open';
            logger.warn(`[GUARD] DB write failed - exit aborted for trade ${position.id.slice(0, 8)}...`);
            return false;
        }

        // Apply NET P&L to capital (same value as [PNL_USD])
        try {
            await capitalManager.applyPNL(position.id, netPnlUsd);
        } catch (err: any) {
            logger.error(`[EXECUTION] Failed to apply P&L: ${err.message}`);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Persist exit to positions table ONLY (trades table already updated above)
        // NOTE: Even if this fails, the trade exit is already recorded in trades table.
        // We log prominently but don't abort since the primary record exists.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        try {
            await persistTradeExit(position.id, {
                exitPrice: position.currentPrice,
                exitTime: Date.now(),
                pnl: netPnlUsd,
                pnlUsd: netPnlUsd,
                pnlPercent: position.pnlPercent,
                exitReason: reason,
                exitAssetValueUsd: exitAssetValueUsd,
                exitFeesPaid: exitFeesPaid,
                exitSlippageUsd: exitSlippageUsd,
            });
        } catch (persistErr: unknown) {
            const errorMsg = persistErr instanceof Error ? persistErr.message : String(persistErr);
            // Log very prominently - positions table is out of sync with trades
            logger.error(`[DB-ERROR] ${JSON.stringify({
                op: 'PERSIST_TRADE_EXIT',
                id: position.id,
                pool: position.pool.slice(0, 8),
                errorMessage: errorMsg,
                warning: 'POSITIONS TABLE OUT OF SYNC - trades table updated but positions table failed',
                pnlUsd: netPnlUsd,
                exitReason: reason,
            })}`);
        }

        // Update state
        position.closed = true;
        position.closedAt = Date.now();
        position.exitReason = reason;
        position.exitState = 'closed';
        position.pendingExit = false;

        this.closedPositions.push({ ...position });
        
        // Reset MTM error counter on successful exit
        resetConsecutiveUnchangedCount();
        
        // Cleanup
        unregisterPosition(position.pool);
        clearEntryBaseline(position.pool);
        clearNegativeVelocityCount(position.pool);
        unregisterHarmonicTrade(position.id);
        markTradeClosed(position.id);
        unregisterTrade(position.id);
        clearPositionMtmCache(position.id); // Clear MTM staleness tracking

        const holdTime = position.closedAt - position.openedAt;
        const pnlSign = netPnlUsd >= 0 ? '+' : '';

        // Log exit to database (use netPnlUsd for consistency with [CAPITAL] and [PNL_USD])
        try {
            await logAction('TRADE_EXIT', {
                tradeId: position.id,
                poolAddress: position.pool,
                poolName: position.symbol,
                exitPrice: position.currentPrice,
                entryPrice: position.entryPrice,
                sizeUSD: position.sizeUSD,
                pnl: netPnlUsd,
                pnlPercent: position.pnlPercent,
                holdTimeMs: holdTime,
                reason,
                caller,
                regime: position.entryRegime,
            });
        } catch (logErr) {
            logger.warn(`[EXECUTION] Failed to log TRADE_EXIT: ${logErr}`);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GET UPDATED TOTAL REALIZED PNL â€” for structured exit log
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let updatedTotalRealizedPnL = this.cachedRealizedPnL + netPnlUsd;
        try {
            const state = await capitalManager.getFullState();
            if (state) {
                updatedTotalRealizedPnL = state.total_realized_pnl;
                this.cachedRealizedPnL = updatedTotalRealizedPnL;
            }
        } catch {
            // Use calculated value if DB unavailable
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STRUCTURED TRADE-EXIT LOG â€” MTM-Based Values (Tier-0 Correctness Fix)
        // exitValueUSD now uses MTM, not old priceChange * sizeUSD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        logTradeExit({
            positionId: position.id,
            poolId: position.pool,
            symbol: position.symbol,
            exitPrice: position.currentPrice,
            exitTime: new Date().toISOString(),
            entryNotionalUSD: position.sizeUSD,
            grossExitValueUSD: exitAssetValueUsd,
            // Explicit entry/exit/total fees (Tier-4 semantics)
            entryFeesUSD: entryFeesUsd,
            exitFeesUSD: exitFeesPaid,
            totalFeesUSD: totalFeesUsd,
            // Explicit entry/exit/total slippage (Tier-4 semantics)
            entrySlippageUSD: entrySlippageUsd,
            exitSlippageUSD: exitSlippageUsd,
            totalSlippageUSD: totalSlippageUsd,
            // PnL breakdown â€” NOW MTM-BASED
            grossPnLUSD: grossPnl,
            netPnLUSD: netPnlUsd,
            pnlPercent: mtm.pnlPercent,
            holdTimeMs: holdTime,
            exitReason: reason,
            updatedTotalRealizedPnLUSD: updatedTotalRealizedPnL,
        });
        
        // Additional MTM-specific log for debugging (includes mtmValueUSD, feesAccruedUSD, unrealizedPnLUSD)
        logTradeExitWithMtm(position.id, position.symbol, mtm, reason, caller);

        logger.info(
            `[TRADE_EXIT] reason="${reason}" ` +
            `pool=${position.pool.slice(0, 8)}... ` +
            `pnl=${pnlSign}$${netPnlUsd.toFixed(2)} (${pnlSign}${(position.pnlPercent * 100).toFixed(2)}%) ` +
            `holdTime=${this.formatDuration(holdTime)} ` +
            `caller=${caller}`
        );

        return true;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    private calculateBinRange(activeBin: number, halfWidth: number = 2): number[] {
        const bins: number[] = [];
        for (let i = -halfWidth; i <= halfWidth; i++) {
            bins.push(activeBin + i);
        }
        return bins;
    }

    private binToPrice(bin: number): number {
        return 1 + (bin * TICK_SPACING_ESTIMATE);
    }

    private updatePositionPrice(position: Position, pool: ScoredPool): void {
        const currentPrice = this.binToPrice(pool.activeBin);
        position.currentPrice = currentPrice;
        
        position.currentBin = pool.activeBin;
        position.binOffset = Math.abs(pool.activeBin - position.entryBin);

        const priceChange = (currentPrice - position.entryPrice) / position.entryPrice;
        position.pnlPercent = priceChange;
        position.pnl = priceChange * position.sizeUSD;
    }

    private estimateVolatility(pool: ScoredPool): number {
        const metrics = pool.microMetrics;
        if (!metrics) return 0.5;
        return Math.min(1, metrics.binVelocity / 100);
    }

    private formatDuration(ms: number): string {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) return `${hours}h ${minutes % 60}m`;
        if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
        return `${seconds}s`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEBUG / INSPECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    public async printStatus(): Promise<void> {
        const status = await this.getPortfolioStatus();
        
        // Extract DB-derived counts from extended status
        const extendedStatus = status as PortfolioSnapshot & { dbOpenCount?: number; dbClosedCount?: number };
        const dbOpenCount = extendedStatus.dbOpenCount ?? status.openPositions.length;
        const dbClosedCount = extendedStatus.dbClosedCount ?? status.closedPositions.length;
        
        const divider = 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
        logger.info(`\n${divider}`);
        logger.info('PORTFOLIO STATUS (DB-GROUND-TRUTH)');
        logger.info(divider);
        logger.info(`Available:    $${status.capital.toFixed(2)}`);
        logger.info(`Locked:       $${status.lockedCapital.toFixed(2)}`);
        logger.info(`Total Equity: $${status.totalEquity.toFixed(2)}`);
        logger.info(`Realized:     $${status.realized.toFixed(2)}`);
        logger.info(`Unrealized:   $${status.unrealized.toFixed(2)}`);
        logger.info(`Net Equity:   $${status.equity.toFixed(2)}`);
        // Use DB-derived counts for consistency
        logger.info(`Open Pos:     ${dbOpenCount} (DB) / ${status.openPositions.length} (memory)`);
        logger.info(`Closed Pos:   ${dbClosedCount} (DB) / ${status.closedPositions.length} (memory)`);
        logger.info('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
        
        if (status.openPositions.length > 0) {
            logger.info('OPEN POSITIONS (in-memory):');
            for (const pos of status.openPositions) {
                const pnlSign = pos.pnl >= 0 ? '+' : '';
                logger.info(`  ${pos.symbol} | $${pos.sizeUSD.toFixed(0)} | ${pnlSign}$${pos.pnl.toFixed(2)} (${pnlSign}${(pos.pnlPercent * 100).toFixed(2)}%)`);
                logger.info(`    Tier4: ${pos.entryTier4Score.toFixed(1)} | Regime: ${pos.entryRegime} | Bin: ${pos.entryBin}â†’${pos.currentBin}`);
            }
        } else if (dbOpenCount > 0) {
            logger.warn(`[PORTFOLIO-WARN] DB has ${dbOpenCount} open positions but engine has 0 in-memory. Recovery may be needed.`);
        }
        
        logger.info(divider + '\n');
    }

    public getConfig(): ExecutionEngineConfig {
        return {
            capital: this.initialCapital,
            takeProfit: this.takeProfit,
            stopLoss: this.stopLoss,
            maxConcurrentPools: this.maxConcurrentPools,
            allocationStrategy: this.allocationStrategy,
        };
    }

    public async reset(): Promise<void> {
        await this.closeAll('RESET');
        await capitalManager.reset(this.initialCapital);
        
        this.positions = [];
        this.closedPositions = [];
        this.poolQueue = [];
        
        logger.info('[EXECUTION] Engine reset to initial state');
    }
}

export default ExecutionEngine;
